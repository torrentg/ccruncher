
//===========================================================================
//
// CreditCruncher - A portfolio credit risk valorator
// Copyright (C) 2005 Gerard Torrent
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
//
//
// Survival.cpp - Survival code
// --------------------------------------------------------------------------
//
// 2005/05/14 - Gerard Torrent [gerard@fobos.generacio.com]
//   . initial release
//
// 2005/05/20 - Gerard Torrent [gerard@fobos.generacio.com]
//   . implemented Strings class
//
// 2005/06/29 - Gerard Torrent [gerard@fobos.generacio.com]
//   . modified inverse function (changed round per ceil)
//
// 2005/07/21 - Gerard Torrent [gerard@fobos.generacio.com]
//   . added class Format (previously format function included in Parser)
//
// 2005/07/29 - Gerard Torrent [gerard@fobos.generacio.com]
//   . improved performance for inverse method
//
//===========================================================================

#include <cmath>
#include <cfloat>
#include <cassert>
#include "survival/Survival.hpp"
#include "utils/Arrays.hpp"
#include "utils/Format.hpp"
#include "utils/Strings.hpp"

// --------------------------------------------------------------------------

#define ISURVFNUMBINS 100

//===========================================================================
// private initializator
//===========================================================================
void ccruncher::Survival::init(Ratings *ratings_) throw(Exception)
{
  maxmonths = 0;
  ratings = ratings_;
  epsilon = 1e-12;

  nratings = ratings->getRatings()->size();

  if (nratings <= 0) {
    throw Exception("Survival::init(): invalid number of ratings");
  }
  else {
    ddata = new vector<double>[nratings];
    idata = Arrays<int>::allocMatrix(nratings, ISURVFNUMBINS+1, 0);
  }
}

//===========================================================================
// constructor
//===========================================================================
ccruncher::Survival::Survival(Ratings *ratings_) throw(Exception)
{
  // posem valors per defecte
  init(ratings_);
}

//===========================================================================
// constructor
// fill values using a matrix (generated by survival function)
// see TransitionMatrix class and mtrans tool class
//===========================================================================
ccruncher::Survival::Survival(Ratings *ratings_, int numrows, int *imonths, double **values,
             int maxmonths_) throw(Exception)
{
  // initializing
  init(ratings_);
  maxmonths = maxmonths_;

  // adding values
  for(int i=0;i<nratings;i++)
  {
    string srating = ratings->getName(i);

    for(int j=0;j<numrows;j++)
    {
      insertValue(srating, imonths[j], values[i][j]);
    }
  }

  // final tasks
  validate();
  fillHoles();
  computeInvTable();
}

//===========================================================================
// destructor
//===========================================================================
ccruncher::Survival::~Survival()
{
  if (ddata != NULL) {
    delete [] ddata;
  }
  if (idata != NULL) {
    Arrays<int>::deallocMatrix(idata, nratings);
  }
}

//===========================================================================
// insert an element
//===========================================================================
void ccruncher::Survival::insertValue(const string &srating, int t, double value) throw(Exception)
{
  int irating = ratings->getIndex(srating);

  // checking rating index
  if (irating < 0 || irating > nratings)
  {
    string msg = "Survival::insertValue(): undefined rating at <survival>: ";
    msg += srating;
    throw Exception(msg);
  }

  // validating time
  if (t < 0)
  {
    string msg = "Survival::insertValue(): value[";
    msg += srating;
    msg += "][";
    msg += Format::int2string(t);
    msg += "] has time < 0";
    throw Exception(msg);
  }

  // validating value
  if (value < -epsilon || value-1.0 > epsilon)
  {
    string msg = "Survival::insertValue(): value[";
    msg += srating;
    msg += "][";
    msg += Format::int2string(t);
    msg += "] out of range: ";
    msg += Format::double2string(value);
    throw Exception(msg);
  }

  // checking that is not previously defined
  if ((int) ddata[irating].size() >= t+1 && !isnan(ddata[irating][t]))
  {
    string msg = "Survival::insertValue(): value[";
    msg += srating;
    msg += "][";
    msg += Format::int2string(t);
    msg += "] redefined";
    throw Exception(msg);
  }

  // allocating space in vector (if needed)
  if ((int) ddata[irating].size() < t+1)
  {
    for(int i=ddata[irating].size();i<t+1;i++)
    {
      ddata[irating].push_back(NAN);
    }
  }

  // inserting value
  ddata[irating][t] = value;
}

//===========================================================================
// epstart - ExpatHandlers method implementation
//===========================================================================
void ccruncher::Survival::epstart(ExpatUserData &eu, const char *name, const char **attributes)
{
  if (isEqual(name,"survival")) {
    if (getNumAttributes(attributes) < 1 || getNumAttributes(attributes) > 2) {
      throw eperror(eu, "invalid number of attributes in tag survival");
    }
    else {
      epsilon = getDoubleAttribute(attributes, "epsilon", 1e-12);
      maxmonths = getIntAttribute(attributes, "maxmonths", INT_MAX);
      if (maxmonths == INT_MAX || maxmonths < 0 || epsilon < 0.0 || epsilon > 0.5) {
        throw eperror(eu, "invalid attributes at <survival>");
      }
    }
  }
  else if (isEqual(name,"svalue")) {
    string srating = getStringAttribute(attributes, "rating", "");
    int t = getIntAttribute(attributes, "t", INT_MAX);
    double value = getDoubleAttribute(attributes, "value", DBL_MAX);

    if (srating == "" || t == INT_MAX || value == DBL_MAX) {
      throw eperror(eu, "invalid values at <svalue>");
    }
    else {
      insertValue(srating, t, value);
    }
  }
  else {
    throw eperror(eu, "unexpected tag " + string(name));
  }
}

//===========================================================================
// epend - ExpatHandlers method implementation
//===========================================================================
void ccruncher::Survival::epend(ExpatUserData &eu, const char *name)
{
  if (isEqual(name,"survival")) {
    validate();
    fillHoles();
    computeInvTable();
  }
  else if (isEqual(name,"svalue")) {
    // nothing to do
  }
  else {
    throw eperror(eu, "unexpected end tag " + string(name));
  }
}

//===========================================================================
// validate given values
//===========================================================================
void ccruncher::Survival::validate() throw(Exception)
{
  // checking ranges, that all values are between 0 and 1 is checked
  // at insertion function. don't rechecked here

  // checking that all ratings (except default) have survival function defined
  for (int i=0;i<nratings-1;i++)
  {
    if (ddata[i].size() <= 0) {
      string msg = "Survival::validate(): rating ";
      msg += ratings->getName(i) + " haven't survival function defined";
      throw Exception(msg);
    }
  }

  // checking survival function value at t=0 is 1 if rating != default
  for (int i=0;i<nratings-1;i++)
  {
    if (isnan(ddata[i][0]))
    {
      ddata[i][0] = 1.0;
    }
    if (fabs(ddata[i][0]-1.0) > epsilon)
    {
      string msg = "Survival::validate(): rating ";
      msg += ratings->getName(i) + " have a value distinct that 1 at t=0";
      throw Exception(msg);
    }
  }

  // checking default rating survival function values (always 0)
  for (unsigned int j=0;j<ddata[nratings-1].size();j++)
  {
    if (isnan(ddata[nratings-1][j])) {
      ddata[nratings-1][0] = 0.0;
    }
    if (fabs(ddata[nratings-1][j]) > epsilon)
    {
      throw Exception("Survival::validate(): default rating have a survival value distinct that 0");
    }
  }

  // checking monotonicity
  for (int i=0;i<nratings-1;i++)
  {
    double pvalue = 2.0;

    for (unsigned int j=0;j<ddata[i].size();j++)
    {
      if (!isnan(ddata[i][j]))
      {
        if (ddata[i][j] <= pvalue)
        {
          pvalue = ddata[i][j];
        }
        else
        {
          string msg = "Survival::validate(): rating ";
          msg += ratings->getName(i) + " is not monotone at t=" + Format::int2string(j);
          throw Exception(msg);
        }
      }
    }
  }
}

//===========================================================================
// interpole
//===========================================================================
double ccruncher::Survival::interpole(double x, double x0, double y0, double x1, double y1)
{
  if (fabs(x1-x0) < 1e-14) {
    return y0;
  } else {
    return y0 + (x-x0)*(y1-y0)/(x1-x0);
  }
}

//===========================================================================
// interpole non given values
//===========================================================================
void ccruncher::Survival::fillHoles()
{
  double x0, x1, y0, y1;

  for(int i=0;i<nratings-1;i++)
  {
    x0 = 0.0;
    y0 = 1.0;

    for(unsigned int j=1;j<ddata[i].size();j++)
    {
      if (!isnan(ddata[i][j]))
      {
        x1 = double(j);
        y1 = ddata[i][j];

        for (unsigned int k=(unsigned int)(x0)+1;k<j;k++)
        {
          ddata[i][k] = interpole(double(k), x0, y0, x1, y1);
        }

        x0 = double(j);
        y0 = ddata[i][j];
      }
    }
  }

  // default rating values (always 0)
  for(unsigned int j=0;j<ddata[nratings-1].size();j++)
  {
    ddata[nratings-1][j] = 0.0;
  }
}

//===========================================================================
// compute the inverse table
// for each rating, find inverse values for 0.01, 0.02, ..., 0.99 and set
// into idata. idata is used to speed up inverse() computations
//===========================================================================
void ccruncher::Survival::computeInvTable()
{
  for (int irating=0;irating<nratings-1;irating++)
  {
    for(int j=0;j<ISURVFNUMBINS+1;j++)
    {
      idata[irating][j] = inverse1(irating, double(j)/double(ISURVFNUMBINS));
    }
  }
  for(int j=0;j<ISURVFNUMBINS+1;j++)
  {
    idata[nratings-1][j] = 0;
  }
}

//===========================================================================
// evalue irating-survival function at time (in months) t
//===========================================================================
double ccruncher::Survival::evalue(const int irating, int t)
{
  assert(irating < nratings);
  assert(irating >= 0);
  assert(t >= 0);

  // if default rating
  if (irating == nratings-1) {
    return 0.0;
  }

  if (t < (int) ddata[irating].size())
  {
    return ddata[irating][t];
  }
  else if (t > maxmonths)
  {
    return 0.0;
  }
  else
  {
    double y0 = ddata[irating].back();
    double y1 = 0.0;
    double x0 = double(ddata[irating].size())-1.0;
    double x1 = double(maxmonths);

    return interpole(double(t), x0, y0, x1, y1);
  }
}

//===========================================================================
// internal inverse function [see inverse() method]
// non optimal method based on secuential scan
//===========================================================================
int ccruncher::Survival::inverse1(const int irating, double val)
{
  assert(irating < nratings);
  assert(irating >= 0);
  assert(val-1.0 < epsilon);
  assert(val > -epsilon);

  // if default rating
  if (irating == nratings-1) {
    assert(fabs(val) < epsilon);
    return 0;
  }

  // if sure -> t=0
  if (val == 1.0) {
    return 0;
  }

  if (val > ddata[irating].back())
  {
    int n = ddata[irating].size();
    for (int j=1;j<n;j++)
    {
      if (ddata[irating][j] <= val)
      {
        //double x0 = ddata[irating][j-1];
        //double x1 = ddata[irating][j];
        //double y0 = double(j-1);
        //double y1 = double(j);
        //return int(ceil(interpole(val, x0, y0, x1, y1)));
        return j;
      }
    }

    // error if value not found
    assert(false);
    return 0;
  }
  else
  {
    double x0 = ddata[irating].back();
    double x1 = 0.0;
    double y0 = double(ddata[irating].size())-1.0;
    double y1 = double(maxmonths);

    return int(ceil(interpole(val, x0, y0, x1, y1)));
  }
}

//===========================================================================
// evalue inverse irating-survival function. returns the time in months
// obs: val is a value in [0,1]
//===========================================================================
int ccruncher::Survival::inverse(const int irating, double val)
{
  assert(val >= 0.0 && val <= 1.0);

  int n = ddata[irating].size();
  int i1 = int(ceil(val*ISURVFNUMBINS));
  //double xt1 = double(i1)/double(ISURVFNUMBINS);
  int t1 = idata[irating][i1];

  // defaults rating allways default at time 0
  if (irating == nratings-1) {
    return 0;
  };

  // if val=0 => maxmonths
  if (val == 0.0) {
    return maxmonths;
  };

  // iterating over T from t1
  for (int j=t1;j<n;j++)
  {
    if (ddata[irating][j] <= val)
    {
      return j;
    }
  }

  // is important the '+1'
  return (t1+1>maxmonths?maxmonths:t1+1);
}

//===========================================================================
// getXML
//===========================================================================
string ccruncher::Survival::getXML(int ilevel) throw(Exception)
{
  string spc1 = Strings::blanks(ilevel);
  string spc2 = Strings::blanks(ilevel+2);
  string ret = "";

  ret += spc1 + "<survival maxmonths='" + Format::int2string(maxmonths) + "' ";
  ret += "epsilon='" + Format::double2string(epsilon) + "'>\n";

  for(int i=0;i<nratings;i++)
  {
    for(unsigned int j=0;j<ddata[i].size();j++)
    {
      ret += spc2 + "<svalue ";
      ret += "rating='" + ratings->getName(i) + "' ";
      ret += "t='" + Format::int2string(j) + "' ";
      ret += "value ='" + Format::double2string(ddata[i][j]) + "'";
      ret += "/>\n";
    }
  }

  ret += spc1 + "</survival>\n";

  return ret;
}

//===========================================================================
// evalue
//===========================================================================
void ccruncher::Survival::evalue(int steplength, int numrows, double **ret)
{
  for(int i=0;i<nratings;i++)
  {
    for(int j=0;j<numrows;j++)
    {
      ret[i][j] = evalue(i, steplength*j);
    }
  }
}
